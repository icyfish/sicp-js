<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>1. 利用函数构造抽象 | SICP JavaScript Version</title><meta name="description" content="Translation of SICP JavaScript Version">
    <link rel="modulepreload" href="/sicp-js/assets/app.07e6cbcb.js"><link rel="modulepreload" href="/sicp-js/assets/1.abstraction-with-functions.html.ed8596aa.js"><link rel="modulepreload" href="/sicp-js/assets/1.abstraction-with-functions.html.3e09d18e.js">
    <link rel="stylesheet" href="/sicp-js/assets/style.a3096ba0.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/sicp-js/" class=""><!----><span class="site-name">SICP JavaScript Version</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/sicp-js" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/sicp-js" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/sicp-js/ch00/foreword.md" class="sidebar-item sidebar-heading" aria-label="0. 前言"><!--[--><!--]--> 0. 前言 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/sicp-js/ch00/foreword-sicp-1984.md" class="sidebar-item" aria-label="Foreword to SICP, 1984"><!--[--><!--]--> Foreword to SICP, 1984 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/sicp-js/ch01/1.abstraction-with-functions.md" class="sidebar-item sidebar-heading active" aria-label="1. 利用函数构造抽象"><!--[--><!--]--> 1. 利用函数构造抽象 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/sicp-js/ch01/1.1.elements-of-programming.md" class="sidebar-item" aria-label="1.1 编程的元素"><!--[--><!--]--> 1.1 编程的元素 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/sicp-js/ch01/1.1.1.expressions.md" class="sidebar-item" aria-label="1.1.1 表达式"><!--[--><!--]--> 1.1.1 表达式 <!--[--><!--]--></a><!----></li><li><a href="/sicp-js/ch01/1.1.2.naming-and-environment.md" class="sidebar-item" aria-label="1.1.2 命名与环境"><!--[--><!--]--> 1.1.2 命名与环境 <!--[--><!--]--></a><!----></li><li><a href="/sicp-js/ch01/1.1.3.evaluating-operator-combinations.md" class="sidebar-item" aria-label="1.1.3 计算运算符组合"><!--[--><!--]--> 1.1.3 计算运算符组合 <!--[--><!--]--></a><!----></li><li><a href="/sicp-js/ch01/1.1.4.compound-functions" class="sidebar-item" aria-label="1.1.4 复合函数"><!--[--><!--]--> 1.1.4 复合函数 <!--[--><!--]--></a><!----></li><li><a href="/sicp-js/ch01/1.1.5.substitution-model" class="sidebar-item" aria-label="1.1.5 函数调用的替代模型"><!--[--><!--]--> 1.1.5 函数调用的替代模型 <!--[--><!--]--></a><!----></li><li><a href="/sicp-js/ch01/1.1.6.conditional-expressions-predicates" class="sidebar-item" aria-label="1.1.6 条件表达式和断言"><!--[--><!--]--> 1.1.6 条件表达式和断言 <!--[--><!--]--></a><!----></li><li><a href="/sicp-js/ch01/1.1.7.square-roots" class="sidebar-item" aria-label="1.1.7 示例: 牛顿法实现平方根"><!--[--><!--]--> 1.1.7 示例: 牛顿法实现平方根 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="_1-利用函数构造抽象" tabindex="-1"><a class="header-anchor" href="#_1-利用函数构造抽象" aria-hidden="true">#</a> 1. 利用函数构造抽象</h1><p><a href="https://sourceacademy.org/sicpjs/1" target="_blank" rel="noopener noreferrer">Original<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><div class="custom-container tip"><p class="custom-container-title">Quote</p><p>The acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three: 1. Combining several simple ideas into one compound one, and thus all complex ideas are made. 2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at once, without uniting them into one, by which it gets all its ideas of relations. 3. The third is separating them from all other ideas that accompany them in their real existence: this is called abstraction, and thus all its general ideas are made.</p><ul><li>John Locke, An Essay Concerning Human Understanding (1690)</li></ul><p>心智, 主要通过这三个方面, 在简单的概念下发挥了它的力量:</p><ol><li>将多个简单的想法组合成一个, 促成了复杂想法的实现.</li><li>将两个不同的想法(简单或复杂)进行组合,</li></ol></div><p>我们即将开始学习<strong>计算过程</strong>的概念. 计算过程是计算机中的抽象概念. 随着计算过程这个概念的逐步发展, 它开始能够控制其他的抽象概念: <strong>数据</strong>. 计算过程的发展遵循一系列的规则, 我们将这些规则叫做<strong>程序</strong>. 我们创建程序来指导计算过程. 相当于我们用自己的咒语召唤出计算机的灵魂.</p><p>计算过程实际上跟巫师的灵魂很相似. 它看不见摸不着, 并不是实际的物质. 但是计算过程在某些方面却有十分真实. 它从事的是脑力工作, 能够解答各种问题, 能够通过实现在银行中的支付工作或者控制工厂中机器人的手给整个世界带来影响. 用于实现计算过程的程序就像是巫师的咒语. 程序由神秘晦涩的<strong>编程语言</strong>所创造的一系列抽象的表达式组合而成, 这些表达式规定了一些任务, 我们希望计算过程去执行的任务.</p><p>在一个功能正常的计算机中, 计算过程能够准确地执行程序. 就像巫师的学徒一样, 新手程序员必须学会理解, 学会预测他们执行咒术之后的结果. 在程序中, 即便是很小的错误(常被称为<strong>缺陷</strong>(<em>bug</em>)), 也有可能带来复杂的不可预测的后果.</p><p>不过幸运的是, 学习编程的危险比学习咒术小多了, because the spirits we deal with are conveniently contained in a secure way. 尽管如此, 真实世界的编程依然要求程序员认真, 专业以及有智慧. 对于一个计算机辅助设计的程序来说, 即使其中只存在一个小小的缺陷, 也有可能会造成毁灭性的后果. 比如飞机故障, 堤坝坍塌, 工业机器人自毁等.</p><p>资深的软件工程师有设计程序的能力, 因此能够合理地确保计算过程的最终结果能够完成任务. 他们能够提前形象化系统的行为, 知道如何对程序进行设计以避免难以预期的, 会带来灾难性后果的问题发生. 并且如果问题发生, 他们有能力对程序进行调试. 设计精巧的计算型系统, 比如汽车或者核反应器, 设计理念都遵循组合式设计, 因此各个部件都可被替代, 也更容易调试.</p><h2 id="javascript-中的编程" tabindex="-1"><a class="header-anchor" href="#javascript-中的编程" aria-hidden="true">#</a> JavaScript 中的编程</h2><p>我们需要合适的语言来描述计算过程, 本书中我们使用的编程语言是 JavaScript. 正如我们日常的想法都是用自然语言(比如英语, 瑞典语, 中文等)来表达, 量化分析的描述用数学符号来表示, 计算过程的表达使用的是 JavaScript. JavaScript 在 1995 年被设计出来, 以一种内嵌网页的脚本形式控制了浏览器的行为. JavaScript 的设计者是 Brendan Eich. 最开始它的名字是 <code>Mocha</code>, 之后被重命名为 <code>LiveScript</code>, 最后是 JavaScript. 甲骨文拥有 JavaScript 的商标权.</p><p>尽管最开始的设计意图是控制网页, 但 JavaScript 目前已经是个通用的编程语言了. JavaScript <em>解释器</em> 的功能, 是执行用 JavaScript 语言描述的计算过程. 第一个 JavaScript 解释器是 Eich 在网景工作时实现的, 当时被用于网景浏览器中. JavaScript 继承了 Scheme 语言和 Self 语言的核心特性. Scheme 是 Lisp 的一种方言, 最初版本的本书就是用 Lisp 语言呈现的. JavaScript 从 Scheme 中继承了最基础的设计原则, 比如词法作用域, 一等函数, 动态类型等.</p><p>JavaScript 与 Java 尽管命名类似, 但相似之处其实很少, 两者都使用了 C 语言的块结构. 但 Java 和 C, which usually employ compilation to lower-level languages, JavaScript 程序最开始则是由 web 浏览器所解释的. 在网景之后, 不断有其它浏览器提供了对 JavaScript 的解释功能, 这些浏览器包括微软的 IE, 当时那个版本的 JavaScript 名字为 <code>JScript</code>. JavaScript 在控制浏览器这方面的爆火使得为 JavaScript 命名的标准诞生, 这个标准就是 <code>ECMAScript</code>. 初版本的 ECMAScript 标准制定工作由 Guy Lewis Steele Jr. 发起, 1997年6月结束, 当时版本的名称为 ECMA 1997. 第六版, 也就是 ECMAScript 2015, 则是由 Allen Wirfs-Brock 发起, 在 2015 年 6 月被 ECMA 联合大会所采用, 版本名称为 ECMA 2015.</p><p>在网页中嵌入 JavaScript 程序的实践激励了浏览器开发者去实现 JavaScript 解释器. 随着程序越来越复杂, 解释器的执行效率也越来越高, 开发者不断开发出更复杂的编译技术, 比如 JIT(即时编译). 大部分 JavaScript 程序(在本文编著的时间 2021 年)都内嵌在网页中并且被浏览器所解释, 不过与此同时, JavaScript 还逐渐扩大了应用范围, 变成了一个比较通用的编程语言, 在服务器端适用, Node.js 就是一个示例.</p><p>然而, 是浏览器执行 JavaScript 程序的能力使得 JavaScript 变成最合适的编写线上版本计算机程序书的编程语言. 在网页中通过点击的方式执行程序在 JavaScript 中是很常见的功能, 其实这点毋庸置疑, 毕竟 JavaScript 就是被设计出来干这事的. 更重要的是, ES2015 还拥有一系列特性使得 JavaScript 成为学习重要编程概念和数据结构的优秀媒介, 同时也十分适合通过这些概念来阐述与之相关的语言特性. JavaScript 的词法作用域, 一等公民函数, and their syntactic support through lambda expressions provide direct and concise access to functional abstraction, and dynamic typing allows the adaptation to remain close to the Scheme original throughout the book. 由于以上提及或者未提及的种种原因, JavaScript 编程就变得十分有趣了.</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: icyyfish@gmail.com">icyfish</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/sicp-js/assets/app.07e6cbcb.js" defer></script>
  </body>
</html>
