# 1.1.5 函数调用的替代模型

[Original](https://sourceacademy.org/sicpjs/1.1.5)

解释器计算函数调用的过程, 在 [1.1.4 章节](https://icyfish.github.io/sicp-js/ch01/1.1.4.compound-functions.html)中已经有所体现. That is, the interpreter evaluates the elements of the application and applies the function (which is the value of the function expression of the application) to the arguments (which are the values of the argument expressions of the application).

我们可以假设原始函数的调用是被解释器或者库处理的. 对于复合函数来说, 调用过程是这样的:

- 将每一个参数用实际值代入复合参数执行. <sup>1</sup>

我们来看一个实际的例子来更直观地呈现调用过程.

```js 
f(5)
```

我们假设以上代码中的函数 `f` 是在 [1.1.4 章节](https://icyfish.github.io/sicp-js/ch01/1.1.4.compound-functions.html)中已经声明过的函数. 从提取函数 `f` 中返回的表达式开始:

```js 
sum_of_squares(a + 1, a * 2)
```

然后用实际的值 5 替代参数中的 `a`:

```js
sum_of_squares(5 + 1, 5 * 2)
```

在这之后, 我们的问题就变成了计算 `sum_of_square` 代入相关参数后的值. 此时的计算包含三个子任务. 计算函数表达式, 计算参数表达式以获取最终的参数值. 现在 `5 + 1` 的结果是 6, `5 * 2` 的结果是 10, 那么最终传入 `sum_of_square` 函数的参数就是 6 和 10. 这些值会被用以替代 `sum_of_square` 函数体中的参数 `x` 和 `y`, 于是我们的函数表达式就变成了 `square(6) + square(10)`. 再代入 `square` 的声明之后, 就变成了 `(6 * 6) + (10 * 10)`, 计算得出: `36 + 100`, 最终结果就是 `136`.

以上我们所描述的过程被叫做函数调用的 **替代** 模型(_substitution model_).  It can be taken as a model that determines the "meaning" of function application, insofar as the functions in this chapter are concerned. 然而, 我们必须要了解两个重点:

- 替代的目的是帮助我们更好地理解函数调用, 并不是解释器工作原理的描述. Typical interpreters do not evaluate function applications by manipulating the text of a function to substitute values for the parameters. 实际上, "替换" 这一步操作是通过参数所处的本地环境完成的. 我们会在第三章和第四章, 探究解释器原理时, 对此进行更详细的介绍.

- 随着本书内容的不断深入, 对解释器工作原理的呈现也会不断完善, 第五章将会是相关原理的完整描述. 替代模型是我们所要阐述的第一个模型, 之后我们会利用更多的模型来帮助我们理解这些抽象的计算过程. 一般来说, 在科学和工程领域, 我们在构造模型时会先从简单, 不完整的模型开始. 随着探究的深入, 这些简单的模型会逐渐变得不够完善, 必须构造更精确的模型来阐述这些概念. 替代模型当然也不例外. 特别需要注意的是, 当我们在第三章中, 使用可变数据应用函数的时候, 可以发现本章的替代模型已经无法呈现第三章中的内容了, 必须要使用更加复杂的模型才能够. <sup>2</sup>


## Applicative order versus normal order

根据章节 [1.1.4](1.1.4.compound-functions.md) 中对计算过程的描述看, 解释器首先会计算函数表达式和参数表达式, 然后应用对应的结果. 但这并不是执行计算的唯一方式. 另一个计算模型是, 直到参数的值被使用, 才对参数表达式执行计算. 也就是只有当获取到一个只包含运算符和内置方法的表达式的时候, 才会把真实的参数值代入参数表达式, 然后执行计算. 当我们使用这个方法的时候, `f(5)` 的计算过程将会是如下这样:

```
sum_of_squares(5 + 1, 5 * 2)

square(5 + 1)     + square(5 * 2)

(5 + 1) * (5 + 1) + (5 * 2) * (5 * 2)
```

经过计算:

```
6    *    6    +    10   *   10

    36         +        100

              136
```

这个计算模型的结果和我们先前的计算结果一致, 但过程存在区别. 特别需要注意的是 `5 + 1` 和 `5 * 2` 分别被执行了两次, 相关的表达式是:

```
x * x
```

其中 `x` 分别是 `5 + 1` 和 `5 * 2`.

我们所介绍的后一种方法名为 "fully expand and then reduce", 常被叫做 _normal-order evaluation_ , 这种方式和解释器实际上使用的"计算参数并应用"的方法有所区别. It can be shown that, for function applications that can be modeled using substitution (including all the functions in the first two chapters of this book) and that yield legitimate values, normal-order and applicative-order evaluation produce the same value. (See exercise 1.5 for an instance of an "illegitimate" value where normal-order and applicative-order evaluation do not give the same result.)

JavaScript 使用 applicative-order 计算, 有一部分原因是 额外的