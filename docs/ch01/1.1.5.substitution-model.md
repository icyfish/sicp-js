# 1.1.5 函数调用的替代模型

[Original](https://sourceacademy.org/sicpjs/1.1.5)

解释器计算函数调用的过程, 在 [1.1.4 章节](https://icyfish.github.io/sicp-js/ch01/1.1.4.compound-functions.html)中已经有所体现. 也就是, 解释器计算应用的元素, 并将参数(参数表达式的值)应用到函数中(也就是应用的函数表达式的值).

我们可以假设原始函数的调用是被解释器或者库处理的. 对于复合函数来说, 调用过程是这样的:

- 将每一个参数用实际值代入复合参数执行. <sup>1</sup>

我们来看一个实际的例子来更直观地呈现调用过程.

```js 
f(5)
```

我们假设以上代码中的函数 `f` 是在 [1.1.4 章节](https://icyfish.github.io/sicp-js/ch01/1.1.4.compound-functions.html)中已经声明过的函数. 从提取函数 `f` 中返回的表达式开始:

```js 
sum_of_squares(a + 1, a * 2)
```

然后用实际的值 5 替代参数中的 `a`:

```js
sum_of_squares(5 + 1, 5 * 2)
```

在这之后, 我们的问题就变成了计算 `sum_of_square` 代入相关参数后的值. 此时的计算包含三个子任务. 计算函数表达式, 计算参数表达式以获取最终的函数和参数值. 现在 `5 + 1` 的结果是 6, `5 * 2` 的结果是 10, 那么最终传入 `sum_of_square` 函数的参数就是 6 和 10. 这些值会被用以替代 `sum_of_square` 函数体中的参数 `x` 和 `y`, 于是我们的函数表达式就变成了 `square(6) + square(10)`. 再代入 `square` 的声明之后, 就变成了 `(6 * 6) + (10 * 10)`, 计算得出: `36 + 100`, 最终结果就是 `136`.

以上我们所描述的过程被叫做函数调用的 **替代** 模型(_substitution model_). It can be taken as a model that determines the "meaning" of function application, insofar as the functions in this chapter are concerned. 然而, 我们必须要了解两个重点:

- 替代的目的是帮助我们更好地理解函数调用, 并不是解释器工作原理的描述. Typical interpreters do not evaluate function applications by manipulating the text of a function to substitute values for the parameters. 实际上, "替换" 这一步操作是通过参数所处的本地环境完成的. 我们会在第三章和第四章, 探究解释器原理时, 对此进行更详细的介绍.

- 随着本书内容的不断深入, 对解释器工作原理的呈现也会不断完善, 第五章将会是相关原理的完整描述. 替代模型是我们所要阐述的第一个模型, 之后我们会利用更多的模型来帮助我们理解这些抽象的计算过程. 一般来说, 在科学和工程领域, 我们在构造模型时会先从简单, 不完整的模型开始. 随着探究的深入, 这些简单的模型会逐渐变得不够完善, 必须构造更精确的模型来阐述这些概念. 替代模型当然也不例外. 特别需要注意的是, 当我们在第三章中, 使用可变数据应用函数的时候, 可以发现本章的替代模型已经无法描述第三章中的内容了, 必须要使用更加复杂的模型才可以. <sup>2</sup>


## 应用次序和正常次序

根据章节 [1.1.4](1.1.4.compound-functions.md) 中对计算过程的描述看, 解释器首先会计算函数表达式和参数表达式, 然后应用对应的结果. 但这并不是执行计算的唯一方式. 另一个计算模型是, 直到参数的值被使用, 才对参数表达式执行计算. 也就是只有当获取到一个只包含运算符和内置方法的表达式的时候, 才会把真实的参数值代入参数表达式, 然后执行计算. 当我们使用这个方法的时候, `f(5)` 的计算过程将会是如下这样:

```
sum_of_squares(5 + 1, 5 * 2)

square(5 + 1)     + square(5 * 2)

(5 + 1) * (5 + 1) + (5 * 2) * (5 * 2)
```

经过计算:

```
6    *    6    +    10   *   10

    36         +        100

              136
```

这个计算模型的结果和我们先前的计算结果一致, 但过程存在区别. 特别需要注意的是 `5 + 1` 和 `5 * 2` 分别被执行了两次, 相关的表达式是:

```
x * x
```

其中 `x` 分别是 `5 + 1` 和 `5 * 2`.

我们所介绍的后一种方法名为 "fully expand and then reduce", 常被叫做 **正常次序的计算** (_normal-order evaluation_) , 这种方式和解释器实际上使用的"计算参数并应用"的方法, 也就是 **应用次序的计算**(_applicative order_)有所区别. 可以看出来, 对于能够使用替代模型来描述的函数(包括前两个章节中所有的函数), 只要接受的是合法的参数, 不管是通过正常次序还是应用次序, 都能够计算得出同样的值. ([练习题1.5](https://sourceacademy.org/sicpjs/1.1.6#ex-1.5)中呈现了一个不合法参数的示例, 此时使用正常次序和应用次序会得出不同的结果.)

JavaScript 使用的是应用次序的计算, 有一部分原因是避免同样表达式的多次计算(比如上述例子中的 `5 + 1` 和 `5 * 2`), 能够使计算更加高效. 更重要的是, 当函数无法用替代模型来描述的时候, 正常次序的计算就变得更加复杂了. 但毋庸置疑的是, 正常次序的计算也有很大用处, 具体的细节我们会在第3,4章中提及.

---

[1]. 如果函数体是一系列按顺序的声明, 函数体会通过参数被替换而计算, 应用的最终结果and the value of the application is the value of the return expression of the first return statement encountered.

[2]. 尽管替换的概念比较简单, 但是为替换的过程给上一个严格的数学定义就很复杂了. ....